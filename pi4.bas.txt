PRINT "Compute pi by iterating x=sin(x)"
REM Using ideas from Valentin Albillo and Albert Chan
REM and from Katie Wasserman and Gerson W Barbosa

T=TIME

A%=72  : REM number of decimal digits
PRINT ;"Computing "A%" digits of pi"
REM convert from decimal digits to bits
A%=A%*LOG(10)/LOG(2)+1 : REM now A% is bits of accuracy wanted
PRINT ;"that is "A%" bits of accuracy"

REM convert from bits of accuracy to size of bignums
B%=10^4   : REM base of bignums
N%=1+A%/(LOG(B%)/LOG(2))   : REM size of (big-endian) bignum arrays
PRINT ;"using bignums of "N%" elements in base "B%

REM first element of bignum array is units, rest is fractional
DIM P%(N%)
DIM Q%(N%+2) : REM seem to need a little overhead for multiplication
DIM S%(N%+2)
DIM T%(N%)
DIM A%(N%+2)

P%(1)=3   : REM initial estimate for PI

M%=2   : REM number of angle reductions
PRINT ;"Using "M%" angle reduction(s)"
IF M%=1 R%=5    : REM reduction of the angle 5^M%
IF M%=2 R%=25
IF M%=3 R%=125
IF M%=4 R%=625

REM we get approx 3x the correct bits each time around
correctbits=3
REPEAT
  correctbits=correctbits*3
  groupsneeded% = 4+correctbits/(LOG(B%)/LOG(2))
  IF groupsneeded% > N% THEN groupsneeded%=N%
  PROCnextPi(groupsneeded%)
  PROCprint("P", groupsneeded%)
  IF P%(1)>3 STOP
UNTIL correctbits>A% : REM or until sin has lots of leading zeros

PRINT ;"Done in "(TIME-T)/100" seconds"

END

DEFPROCnextPi(N%)
  REM compute SIN of reduced angle with a series
  REM to accuracy N% elements of the bignum array

  PRINT';"computing sin() with "N%" bignum elements"

  REM P,Â Q, S, T all longs
  REM P is our pi approximation
  REM Q is the square of S (for efficiency)
  REM S is the sin, computed as a sum of terms
  REM T is the next term to add to S
  REM A is an accumulator for the multiplications

  REM sometimes we shuffle values between variables
  REM to make use of the few bignum PROCs we have

  D%=R%  : REM compute T=P/R% with fewer PROCs

  FOR I%=1TON%: A%(I%)=P%(I%) :NEXT :REM  A=P
  PROCdivAbyNgivingT(D%)            :REM  T=A/D% : REM done
  FOR I%=1TON%: S%(I%)=T%(I%) :NEXT :REM  S=T
  PROCsquareStoQ                    :REM  Q=S*S
  D%=0:E%=6:O%=TRUE
  REPEAT
    REM PRINT '"head of sin calc loop"
    D%=D%+E%:E%=E%+8
    O%=NOTO%
    PROCmulTQtoA                    :REM  A=T*Q
    PROCdivAbyNgivingT(D%)          :REM  T=A/D%
    REM PROCprint("T", N%)
    IF O% PROCaddTintoS ELSE PROCtakeTfromS
    REM PROCprint("S", N%)
  UNTIL zero : REM until T is small - detected during division

  REM apply the SIN(5X) transformation
  FOR J%=1 TO M%
    REM PRINT '"head of angle embiggening loop"
    PROCsquareStoQ                     :REM  Q=S*S
    REM PROCprint("Q", N%)
    PROCtimesQby16intoA                :REM  A=Q*16 : REM A less than 6
    PROCtakeAfromNintoT(20)            :REM  T=20-A : REM T less than 20
    REM PROCprint("T", N%)
    PROCmulTQtoA                       :REM  A=T*Q  : REM A under 5
    REM PROCprint("A", N%)
    IF A%(1)>4 PRINT'"A() too big T will go negative":STOP
    PROCtakeAfromNintoT(5)             :REM  T=5-A  : REM T under 5
    REM PROCprint("T", N%)
    FOR I%=1TON%: Q%(I%)=S%(I%) :NEXT  :REM  Q=S    : REM compute S=S*T with fewer PROCs
    PROCmulTQtoA                       :REM  A=T*Q
    FOR I%=1TON%: S%(I%)=A%(I%) :NEXT  :REM  S=A    : REM done
    REM PROCprint("S", N%)
  NEXT J%
  FOR I%=1TON%: T%(I%)=P%(I%) :NEXT  :REM  T=P      : REM compute P=P+S with fewer PROCs
  PROCaddTintoS                      :REM  S=S+T
  FOR I%=1TON%: P%(I%)=S%(I%) :NEXT  :REM  P=S      : REM done

  REM P() now contains the latest approximation to pi
ENDPROC

REM big-endian bignum routines
REM derived from work by Katie and Gerson

REM squaring could be a little cheaper than general multiplication
REM so its a separate PROC
REM and yet it's not written to be cheaper
REM so it's somewhat redundant
REM other than it using different bignums

DEFPROCsquareStoQ : REM Q() gets S() * S()
LOCAL C%,T%,I%,J%  : REM carry, temporary, loop vars
FOR I%=1 TO N%
Q%(I%)=0
NEXT
FOR I%=N% TO 1 STEP -1
C%=0
FOR J%=N%-I%+2 TO -1 STEP -1
T%=(C%+S%(I%)*S%(J%+1))
Q%(I%+J%)=Q%(I%+J%)+T%MODB%
C%=T%DIVB%
NEXT
NEXT
FOR I%=N%+2 TO 2 STEP -1
T%=Q%(I%)
Q%(I%)=T%MODB%
Q%(I%-1)=Q%(I%-1)+T% DIV B%
NEXT
ENDPROC

DEFPROCmulTQtoA : REM A() gets T() times Q()
LOCAL C%,T%,I%,J%  : REM carry, temporary, loop vars
FOR I%=1 TO N%
A%(I%)=0
NEXT
FOR I%=N% TO 1 STEP -1
C%=0
FOR J%=N%-I%+2 TO -1 STEP -1
T%=(C%+T%(I%)*Q%(J%+1))
A%(I%+J%)=A%(I%+J%)+T%MODB%
C%=T%DIVB%
NEXT
NEXT
FOR I%=N%+2 TO 2 STEP -1
T%=A%(I%)
A%(I%)=T%MODB%
A%(I%-1)=A%(I%-1)+T% DIV B%
NEXT
ENDPROC

DEFPROCdivAbyNgivingT(D%) :REM compute T=A/Int
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0 : REM clear carry
zero=TRUE
FOR I%=1 TO N%
T%=A%(I%)+B%*C%
T%(I%)=T%DIVD%:C%=T%MODD%
IF T%(I%)<>0 zero=FALSE
NEXT
ENDPROC

DEFPROCtimesQby16intoA : REM A gets Q() * 16
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0  : REM clear carry
FOR I%=N% TO 1 STEP -1
T%=16*Q%(I%)+C%
A%(I%)=T%MODB%:C%=T%DIVB%
NEXT
ENDPROC

DEFPROCaddTintoS : REM add T() into S()
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0   : REM clear carry
FOR I%=N% TO 1 STEP -1
T%=S%(I%)+T%(I%)+C%
S%(I%)=T%MODB%:C%=T%DIVB%
NEXT
ENDPROC

DEFPROCtakeTfromS : REM subtract T() from S()
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0   : REM clear carry
FOR I%=N% TO 1 STEP -1
T%=S%(I%)-T%(I%)+C%
S%(I%)=(T%+B%)MODB%:IF T%<0 C%=-1 ELSE C%=0
NEXT
ENDPROC

DEFPROCtakeAfromNintoT(N) : REM calculate T=20-A or T=5-A
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0   : REM clear carry
FOR I%=N% TO 1 STEP -1
T%=-A%(I%)+C%
T%(I%)=(T%+B%)MODB%:IF T%<0 C%=-1 ELSE C%=0
NEXT
T%(1)=(T%(1)+N)MODB%
ENDPROC

DEFPROCprint(B$, N%)
LOCAL I% : REM loop var
PRINT ;B$": "EVAL(B$+"%(1)")" ";
FOR I%=2 TO N%
  PRINT ;RIGHT$(STR$(B%+EVAL(B$+"%(I%)")),LEN(STR$(B%))-1)" ";
NEXT
PRINT
ENDPROC
