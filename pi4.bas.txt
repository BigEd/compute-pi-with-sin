REM Compute pi by iterating x=sin(x)
REM Using ideas from Valentin Albillo and Albert Chan
REM and from Katie Wasserman and Gerson W Barbosa

A%=200 : REM bits of accuracy wanted
M%=2   : REM number of angle reductions

REM first element of bignums is units, rest is fractional
N%=16     : REM size of (big-endian) bignums
B%=10000  : REM base of bignums

DIM P%(N%)
DIM Q%(N%+2) : REM seem to need a little overhead for multiplication
DIM S%(N%+2)
DIM T%(N%)
DIM A%(N%+2)

@%=&1414
P%(1)=3   : REM initial estimate for PI

PRINT ;M%" angle reductions"
IF M%=1 R%=5    : REM reduction of the angle 5^M%
IF M%=2 R%=25
IF M%=3 R%=125
IF M%=4 R%=625

REM we get approx 3x the correct bits each time around
correct=4
REPEAT
  REM PRINT'"head of outer loop"
  correct=correct*3

  REM compute SIN of reduced angle with a series

  REM P,Â Q, S, T all longs
  REM P is our pi approximation
  REM Q is the square of S (for efficiency)
  REM S is the sin, computed as a sum of terms
  REM T is the next term to add to S
  REM A is an accumulator for the multiplications

  REM sometimes we shuffle values between variables
  REM to make use of the few bignum PROCs we have

  D%=R%  : REM compute T=P/R% with fewer PROCs

  FOR I%=1TON%: A%(I%)=P%(I%) :NEXT :REM  A=P
  PROCdivAbyNgivingT(D%)            :REM  T=A/D% : REM done
  FOR I%=1TON%: S%(I%)=T%(I%) :NEXT :REM  S=T
  PROCsquareStoQ                    :REM  Q=S*S
  D%=0:E%=6:O%=TRUE
  REPEAT
    REM PRINT '"head of sin calc loop"
    D%=D%+E%:E%=E%+8
    O%=NOTO%
    PROCmulTQtoA                    :REM  A=T*Q
    PROCdivAbyNgivingT(D%)          :REM  T=A/D%
    IF O% PROCaddTintoS ELSE PROCtakeTfromS
  UNTIL zero : REM until T is small - detected during division

  REM apply the SIN(5X) transformation
  FOR J%=1 TO M%
    REM PRINT '"head of angle embiggening loop"
    PROCsquareStoQ                     :REM  Q=S*S
    PROCtimesQby16intoA                :REM  A=Q*16 : REM A less than 6
    PROCtakeAfromNintoT(20)            :REM  T=20-A : REM T less than 20
    PROCmulTQtoA                       :REM  A=T*Q  : REM A under 5
    PROCtakeAfromNintoT(5)             :REM  T=5-A  : REM T under 5
    FOR I%=1TON%: Q%(I%)=S%(I%) :NEXT  :REM  Q=S    : REM compute S=S*T with fewer PROCs
    PROCmulTQtoA                       :REM  A=T*Q
    FOR I%=1TON%: S%(I%)=A%(I%) :NEXT  :REM  S=A    : REM done
  NEXT J%
  FOR I%=1TON%: T%(I%)=P%(I%) :NEXT  :REM  T=P      : REM compute P=P+S with fewer PROCs
  PROCaddTintoS                      :REM  S=S+T
  FOR I%=1TON%: P%(I%)=S%(I%) :NEXT  :REM  P=S      : REM done
  PROCprint("P")
UNTIL correct>A% : REM or until sin has lots of leading zeros

END

REM big-endian bignum routines
REM derived from work by Katie and Gerson

REM squaring could be a little cheaper than general multiplication
REM so its a separate PROC
REM and yet it's not written to be cheaper
REM so it's somewhat redundant
REM other than it using different bignums

DEFPROCsquareStoQ : REM Q() gets S() * S()
LOCAL C%,T%,I%,J%  : REM carry, temporary, loop vars
FOR I%=1 TO N%
Q%(I%)=0
NEXT
FOR I%=N% TO 1 STEP -1
C%=0
FOR J%=N%-I%+2 TO -1 STEP -1
T%=(C%+S%(I%)*S%(J%+1))
Q%(I%+J%)=Q%(I%+J%)+T%MODB%
C%=T%DIVB%
NEXT
NEXT
FOR I%=N%+2 TO 2 STEP -1
T%=Q%(I%)
Q%(I%)=T%MODB%
Q%(I%-1)=Q%(I%-1)+T% DIV B%
NEXT
ENDPROC

DEFPROCmulTQtoA : REM A() gets T() times Q()
LOCAL C%,T%,I%,J%  : REM carry, temporary, loop vars
FOR I%=1 TO N%
A%(I%)=0
NEXT
FOR I%=N% TO 1 STEP -1
C%=0
FOR J%=N%-I%+2 TO -1 STEP -1
T%=(C%+T%(I%)*Q%(J%+1))
A%(I%+J%)=A%(I%+J%)+T%MODB%
C%=T%DIVB%
NEXT
NEXT
FOR I%=N%+2 TO 2 STEP -1
T%=A%(I%)
A%(I%)=T%MODB%
A%(I%-1)=A%(I%-1)+T% DIV B%
NEXT
ENDPROC

DEFPROCdivAbyNgivingT(D%) :REM compute T=A/Int
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0 : REM clear carry
zero=TRUE
FOR I%=1 TO N%
T%=A%(I%)+B%*C%
T%(I%)=T%DIVD%:C%=T%MODD%
IF T%(I%)<>0 zero=FALSE
NEXT
ENDPROC

DEFPROCtimesQby16intoA : REM A gets Q() * 16
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0  : REM clear carry
FOR I%=N% TO 1 STEP -1
T%=16*Q%(I%)+C%
A%(I%)=T%MODB%:C%=T%DIVB%
NEXT
ENDPROC

DEFPROCaddTintoS : REM add T() into S()
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0   : REM clear carry
FOR I%=N% TO 1 STEP -1
T%=S%(I%)+T%(I%)+C%
S%(I%)=T%MODB%:C%=T%DIVB%
NEXT
ENDPROC

DEFPROCtakeTfromS : REM subtract T() from S()
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0   : REM clear carry
FOR I%=N% TO 1 STEP -1
T%=S%(I%)-T%(I%)+C%
S%(I%)=(T%+B%)MODB%:IF T%<0 C%=-1 ELSE C%=0
NEXT
ENDPROC

DEFPROCtakeAfromNintoT(N) : REM calculate T=20-A or T=5-A
LOCAL C%,T%,I% : REM carry, temporary, loop var
C%=0   : REM clear carry
FOR I%=N% TO 1 STEP -1
T%=-A%(I%)+C%
T%(I%)=(T%+B%)MODB%:IF T%<0 C%=-1 ELSE C%=0
NEXT
T%(1)=(T%(1)+N)MODB%
ENDPROC

DEFPROCprint(B$)
LOCAL I% : REM loop var
PRINT B$": ";
FOR I%=1 TO N%
  PRINT ;EVAL(B$+"%(I%)")" ";
NEXT
PRINT
ENDPROC
